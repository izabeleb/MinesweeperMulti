"""Defines the Client used to send adn receive data to the server."""
from minefield.MineField import MineField
from mode import Mode
import minesweeper
import asyncio
import struct
import json


class Client(asyncio.Protocol):
    """Client used to send and receive mine_field data and changes."""

    @staticmethod
    def get_packet_size(packet: bytes) -> bytes:
        """Get the size of the packet in network byte order."""
        return struct.pack('!I', len(packet))

    def __init__(self, game_mode: Mode = Mode()):
        super().__init__()
        self._mode = game_mode
        self.transport: asyncio.Transport = None
        self._buffer: bytes = b''
        self._mine_field: MineField = None

    def connection_made(self, transport) -> None:
        """Establish values pertinent to the server connection.

        Args:
            transport: the TCP connection interface used to send and
                read data to and from the server.
        """
        self.transport = transport
        print(f'Client connected as'
              f'{self.transport.get_extra_info("peername")}')

    def data_received(self, data: bytes) -> None:
        """Handle data read from the server.

        Args:
            data (bytes): the data read from the server socket.
        """
        self._buffer += data

        while len(self._buffer) > 4:
            packet_length: int = struct.unpack('!I', self._buffer[:4:])[0]

            if len(self._buffer) < 4 + packet_length:
                break

            self._buffer = self._buffer[4::]

            packet: dict = json.loads(self._buffer[:packet_length:].decode())

            affected_row: int = -1
            affected_col: int = -1

            if 'CELLS' in packet:
                self._mine_field = MineField.decode(
                    self._buffer[:packet_length:])
                print('field received')

            if 'ROW' in packet:
                affected_row = packet['ROW']
            if 'COL' in packet:
                affected_col = packet['COL']
            if 'ACTION' in packet:
                action: str = packet['ACTION']
                affected_cell = self._mine_field.get_cell_at(affected_row,
                                                             affected_col)
                if action == 'FLAG':
                    affected_cell.set_flag(True)
                    affected_cell.set_clicked(True)
                elif action == 'HIT':
                    affected_cell.set_clicked(True)

            self._buffer = self._buffer[packet_length::]

    def connection_lost(self, exc) -> None:
        """Handle loos of server connection.

        Args:
            exc (Exception): the exception raised when the connection wa lost.
        """
        pass

    def request_server_field(self) -> None:
        """Get the mine_filed generated by the server."""
        request: bytes = json.dumps({'ACTION': "FIELD"}).encode()
        request_len: bytes = Client.get_packet_size(request)
        self.transport.write(request_len + request)

    def send_change(self, row: int, col: int, change_type: str) -> None:
        """Send a local change to the server.

        There are TWO types of changes which can be made:
            1 ) HIT
            2 ) FLAG

        Args:
            row (int): the row location of the change.
            col (int): the col location of te change.
            change_type (in): integer representing the type of change
                made.
        """
        change_json: dict = {'ROW': row, 'COL': col, 'ACTION': change_type}
        change_json: bytes = json.dumps(change_json).endode()
        change_len: bytes = Client.get_packet_size(change_json)

        self.transport.write(change_len + change_json)

    def move_mine(self, old_loc: tuple, new_loc: tuple) -> None:
        """Notify the server that a mine has been relocated.

        Args:
            old_loc (tuple): the coordinates of the mine's current
                position.
            new_loc (tuple): the coordinates to which to move the mine.
        """
        mine_json: dict = {'MINECHANGE': {'OLD': old_loc, 'NEW': new_loc}}
        mine_json: bytes = json.dumps(mine_json)
        mine_len: bytes = Client.get_packet_size(mine_json)
        self.transport.write(mine_len + mine_json)

    def get_mine_field(self) -> MineField:
        return self._mine_field


def run_client(host: str = 'localhost', port: int = 8080,
               game_mode: Mode = Mode()) -> None:
    loop = asyncio.get_event_loop()
    coro = loop.create_connection(Client, host, port)
    client = loop.run_until_complete(coro)

    print(client[1].get_mine_field())

    # minesweeper.main(game_mode, client[1])

    try:
        loop.run_forever()
    finally:
        loop.close()
