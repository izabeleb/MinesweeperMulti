"""Defines the Client used to send adn receive data to the server."""
from minefield import MineField
import asyncio
import struct
import json


class Client(asyncio.Protocol):
    """Client used to send and receive mine_field data and changes."""

    @staticmethod
    def get_packet_size(packet: bytes) -> bytes:
        """Get the size of the packet in network byte order."""
        return struct.pack('!I', len(packet))

    def connection_made(self, transport) -> None:
        """Establish values pertinent to the server connection.

        Args:
            transport: the TCP connection interface used to send and
                read data to and from the server.
        """
        self.transport = transport
        self._buffer: bytes = b''
        self._mine_field = self.get_server_field()

    def data_received(self, data: bytes) -> None:
        """Handle data read from the server.

        Args:
            data (bytes): the data read from the server socket.
        """
        pass

    def connection_lost(self, exc) -> None:
        """Handle loos of server connection.

        Args:
            exc (Exception): the exception raised when the connection wa lost.
        """

    def get_server_field(self) -> MineField:
        """Get the mine_filed generated by the server."""
        request: bytes = json.dumps({'ACTION': "FIELD"}).encode()
        request_len: bytes = Client.get_packet_size(request)
        self.transport.write(request_len, request)

    def send_change(self, row: int, col: int, change_type: str) -> None:
        """Send a local change to the server.

        There are TWO types of changes which can be made:
            1 ) HIT
            2 ) FLAG

        Args:
            row (int): the row location of the change.
            col (int): the col location of te change.
            change_type (in): integer representing the type of change
                made.
        """
        change_json: dict = {'ROW': row, 'COL': col, 'ACTION': change_type}
        change_json: bytes = json.dumps(change_json).endode()
        change_len: bytes = Client.get_packet_size(change_json)

        self.transport.write(change_len + change_json)


def run_client(host: str = 'localhost', port: int = 8080):
    loop = asyncio.get_event_loop()
    client = Client()
    coro = loop.create_connection(Client, host, port)
    client = loop.run_until_complete(coro)

    try:
        loop.run_forever()
    finally:
        loop.close()
