"""Defines the Client used to send adn receive data to the server."""
from minefield.MineField import MineField
import asyncio
import struct
import json


class Client(asyncio.Protocol):
    """Client used to send and receive mine_field data and changes."""

    @staticmethod
    def get_packet_size(packet: bytes) -> bytes:
        """Get the size of the packet in network byte order."""
        return struct.pack('!I', len(packet))

    def connection_made(self, transport) -> None:
        """Establish values pertinent to the server connection.

        Args:
            transport: the TCP connection interface used to send and
                read data to and from the server.
        """
        self.transport = transport
        self._buffer: bytes = b''
        self._mine_field = self.request_server_field()

    def data_received(self, data: bytes) -> None:
        """Handle data read from the server.

        Args:
            data (bytes): the data read from the server socket.
        """
        self._buffer += data

        while len(self._buffer) > 4:
            packet_length: int = struct.unpack('!I', self._buffer[:4:])[0]

            if len(self._buffer) < 4 + packet_length:
                break

            packet: dict = json.loads(self._buffer[4:packet_length:].decode())
            self._buffer = self._buffer[4 + packet_length::]

            affected_row: int = -1
            affected_col: int = -1

            if 'ROW' in packet:
                affected_row = packet['ROW']
            if 'COL' in packet:
                affected_col = packet['COL']
            if 'ACTION' in packet:
                action: str = packet['ACTION']
                affected_cell = self._mine_field.get_cell_at(affected_row,
                                                             affected_col)
                if action == 'FLAG':
                    affected_cell.set_flag(True)
                    affected_cell.set_clicked(True)
                elif action == 'HIT':
                    affected_cell.set_clicked(True)
            if 'FIELD' in packet:
                self._mine_field = MineField.decode(packet['FIELD'])

    def connection_lost(self, exc) -> None:
        """Handle loos of server connection.

        Args:
            exc (Exception): the exception raised when the connection wa lost.
        """
        pass

    def request_server_field(self) -> None:
        """Get the mine_filed generated by the server."""
        request: bytes = json.dumps({'ACTION': "FIELD"}).encode()
        request_len: bytes = Client.get_packet_size(request)
        self.transport.write(request_len, request)

    def send_change(self, row: int, col: int, change_type: str) -> None:
        """Send a local change to the server.

        There are TWO types of changes which can be made:
            1 ) HIT
            2 ) FLAG

        Args:
            row (int): the row location of the change.
            col (int): the col location of te change.
            change_type (in): integer representing the type of change
                made.
        """
        change_json: dict = {'ROW': row, 'COL': col, 'ACTION': change_type}
        change_json: bytes = json.dumps(change_json).endode()
        change_len: bytes = Client.get_packet_size(change_json)

        self.transport.write(change_len + change_json)

    def get_mine_field(self) -> MineField:
        return self._mine_field


def run_client(host: str = 'localhost', port: int = 8080):
    loop = asyncio.get_event_loop()
    client = Client()
    coro = loop.create_connection(Client, host, port)
    client = loop.run_until_complete(coro)

    try:
        loop.run_forever()
    finally:
        loop.close()
