"""Defines the Client used to send adn receive data to the server."""
import asyncio
import json
import struct
from typing import Optional
from minesweeper import MineField, Mode
from minesweeper.minesweeper import run_minesweeper


class Client(asyncio.Protocol):
    """Client used to send and receive mine_field data and changes.

    Args:
        game_mode (Mode): The mode to run the game in.
    """
    def __init__(self, game_mode: Mode = Mode()):
        super().__init__()
        self.mode = game_mode
        self.transport: Optional[asyncio.Transport] = None
        self._buffer = bytes()
        self.mine_field: Optional[MineField] = None

    def connection_made(self, transport):
        """Establish values pertinent to the server connection.

        Args:
            transport: the TCP connection interface used to send and
                read data to and from the server.
        """
        self.transport = transport
        print(f'Client connected as {self.transport.get_extra_info("peername")}')

    def data_received(self, data: bytes):
        """Handle data read from the server.

        Args:
            data (bytes): the data read from the server socket.
        """
        self._buffer += data

        while len(self._buffer) > 4:
            packet_length: int = struct.unpack('!I', self._buffer[:4:])[0]

            if len(self._buffer) < 4 + packet_length:
                break

            self._buffer = self._buffer[4::]

            packet: dict = json.loads(self._buffer[:packet_length:].decode())

            affected_row: int = -1
            affected_col: int = -1

            if 'CELLS' in packet:
                self.mine_field = MineField.decode(self._buffer[:packet_length:])
                print('field received')

            if 'ROW' in packet:
                affected_row = packet['ROW']
            if 'COL' in packet:
                affected_col = packet['COL']
            if 'ACTION' in packet:
                action: str = packet['ACTION']
                affected_cell = self.mine_field.get_cell_at(affected_row,
                                                            affected_col)
                if action == 'FLAG':
                    affected_cell.flag = True
                    affected_cell.clicked = True
                elif action == 'HIT':
                    affected_cell.clicked = True

            self._buffer = self._buffer[packet_length::]

    def connection_lost(self, exc):
        """Handle loos of server connection.

        Args:
            exc (Exception): the exception raised when the connection wa lost.
        """

    def request_server_field(self):
        """Get the mine_filed generated by the server."""
        request: bytes = json.dumps({'ACTION': "FIELD"}).encode()
        request_len: bytes = Client.get_packet_size(request)
        self.transport.write(request_len + request)

    def send_change(self, row: int, col: int, change_type: str):
        """Send a local change to the server.

        There are TWO types of changes which can be made:
            1 ) HIT
            2 ) FLAG

        Args:
            row (int): the row location of the change.
            col (int): the col location of te change.
            change_type (in): integer representing the type of change
                made.
        """
        change_json: dict = {'ROW': row, 'COL': col, 'ACTION': change_type}
        change_json: bytes = json.dumps(change_json).endode()
        change_len: bytes = Client.get_packet_size(change_json)

        self.transport.write(change_len + change_json)

    def move_mine(self, old_loc: tuple, new_loc: tuple):
        """Notify the server that a mine has been relocated.

        Args:
            old_loc (tuple): the coordinates of the mine's current position.
            new_loc (tuple): the coordinates to which to move the mine.
        """
        mine_json: dict = {'MINECHANGE': {'OLD': old_loc, 'NEW': new_loc}}
        mine_json: bytes = json.dumps(mine_json)
        mine_len: bytes = Client.get_packet_size(mine_json)
        self.transport.write(mine_len + mine_json)

    @staticmethod
    def get_packet_size(packet: bytes) -> bytes:
        """Get the size of the packet in network byte order."""
        return struct.pack('!I', len(packet))


def run_client(host: str, port: int, game_mode: Mode = Mode()):
    """Create and run a new client game."""
    loop = asyncio.get_event_loop()
    client = Client()

    coro = loop.create_connection(lambda: client, host, port)

    client = loop.run_until_complete(coro)

    print(client[1].get_mine_field())

    run_minesweeper(game_mode, client[1])

    try:
        loop.run_forever()
    finally:
        loop.close()
